/**
 * Generated by orval v6.25.0 üç∫
 * Do not edit manually.
 * My awesome API
 * My awesome API created with ZenStack
 * OpenAPI spec version: 0.5.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type { MutationFunction, QueryFunction, QueryKey, UseMutationOptions, UseQueryOptions, UseQueryResult } from "@tanstack/react-query";
import axios from "axios";
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios";
import type {
  AggregatePost200,
  AggregatePostParams,
  AggregateUser200,
  AggregateUserParams,
  CountPost200,
  CountPostParams,
  CountUser200,
  CountUserParams,
  CreatePost201,
  CreateUser201,
  DeleteManyPost200,
  DeleteManyPostParams,
  DeleteManyUser200,
  DeleteManyUserParams,
  DeletePost200,
  DeletePostParams,
  DeleteUser200,
  DeleteUserParams,
  FindFirstPost200,
  FindFirstPostParams,
  FindFirstUser200,
  FindFirstUserParams,
  FindManyPost200,
  FindManyPostParams,
  FindManyUser200,
  FindManyUserParams,
  FindUniquePost200,
  FindUniquePostParams,
  FindUniqueUser200,
  FindUniqueUserParams,
  GroupByPost200,
  GroupByPostParams,
  GroupByUser200,
  GroupByUserParams,
  PostCreateArgs,
  PostUpdateArgs,
  PostUpdateManyArgs,
  PostUpsertArgs,
  UpdateManyPost200,
  UpdateManyUser200,
  UpdatePost200,
  UpdateUser200,
  UpsertPost200,
  UpsertUser200,
  UserCreateArgs,
  UserUpdateArgs,
  UserUpdateManyArgs,
  UserUpsertArgs,
  _Error
} from "./generated.schemas";

/**
 * Create a new User
 */
export const createUser = (userCreateArgs: UserCreateArgs, options?: AxiosRequestConfig): Promise<AxiosResponse<CreateUser201>> => {
  return axios.post(`http://localhost:3000/api/model/user/create`, userCreateArgs, options);
};

export const getCreateUserMutationOptions = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError, { data: UserCreateArgs }, TContext>;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError, { data: UserCreateArgs }, TContext> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, { data: UserCreateArgs }> = (props) => {
    const { data } = props ?? {};

    return createUser(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>;
export type CreateUserMutationBody = UserCreateArgs;
export type CreateUserMutationError = AxiosError<_Error>;

export const useCreateUser = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError, { data: UserCreateArgs }, TContext>;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getCreateUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Find one unique User
 */
export const findUniqueUser = (params: FindUniqueUserParams, options?: AxiosRequestConfig): Promise<AxiosResponse<FindUniqueUser200>> => {
  return axios.get(`http://localhost:3000/api/model/user/findUnique`, {
    ...options,
    params: { ...params, ...options?.params }
  });
};

export const getFindUniqueUserQueryKey = (params: FindUniqueUserParams) => {
  return [`http://localhost:3000/api/model/user/findUnique`, ...(params ? [params] : [])] as const;
};

export const getFindUniqueUserQueryOptions = <TData = Awaited<ReturnType<typeof findUniqueUser>>, TError = AxiosError<_Error>>(
  params: FindUniqueUserParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findUniqueUser>>, TError, TData>>; axios?: AxiosRequestConfig }
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindUniqueUserQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findUniqueUser>>> = ({ signal }) =>
    findUniqueUser(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof findUniqueUser>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type FindUniqueUserQueryResult = NonNullable<Awaited<ReturnType<typeof findUniqueUser>>>;
export type FindUniqueUserQueryError = AxiosError<_Error>;

export const useFindUniqueUser = <TData = Awaited<ReturnType<typeof findUniqueUser>>, TError = AxiosError<_Error>>(
  params: FindUniqueUserParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findUniqueUser>>, TError, TData>>; axios?: AxiosRequestConfig }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getFindUniqueUserQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Find the first User matching the given condition
 */
export const findFirstUser = (params: FindFirstUserParams, options?: AxiosRequestConfig): Promise<AxiosResponse<FindFirstUser200>> => {
  return axios.get(`http://localhost:3000/api/model/user/findFirst`, {
    ...options,
    params: { ...params, ...options?.params }
  });
};

export const getFindFirstUserQueryKey = (params: FindFirstUserParams) => {
  return [`http://localhost:3000/api/model/user/findFirst`, ...(params ? [params] : [])] as const;
};

export const getFindFirstUserQueryOptions = <TData = Awaited<ReturnType<typeof findFirstUser>>, TError = AxiosError<_Error>>(
  params: FindFirstUserParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findFirstUser>>, TError, TData>>; axios?: AxiosRequestConfig }
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindFirstUserQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findFirstUser>>> = ({ signal }) =>
    findFirstUser(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof findFirstUser>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type FindFirstUserQueryResult = NonNullable<Awaited<ReturnType<typeof findFirstUser>>>;
export type FindFirstUserQueryError = AxiosError<_Error>;

export const useFindFirstUser = <TData = Awaited<ReturnType<typeof findFirstUser>>, TError = AxiosError<_Error>>(
  params: FindFirstUserParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findFirstUser>>, TError, TData>>; axios?: AxiosRequestConfig }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getFindFirstUserQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Find a list of User
 */
export const findManyUser = (params: FindManyUserParams, options?: AxiosRequestConfig): Promise<AxiosResponse<FindManyUser200>> => {
  return axios.get(`http://localhost:3000/api/model/user/findMany`, {
    ...options,
    params: { ...params, ...options?.params }
  });
};

export const getFindManyUserQueryKey = (params: FindManyUserParams) => {
  return [`http://localhost:3000/api/model/user/findMany`, ...(params ? [params] : [])] as const;
};

export const getFindManyUserQueryOptions = <TData = Awaited<ReturnType<typeof findManyUser>>, TError = AxiosError<_Error>>(
  params: FindManyUserParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findManyUser>>, TError, TData>>; axios?: AxiosRequestConfig }
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindManyUserQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findManyUser>>> = ({ signal }) =>
    findManyUser(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof findManyUser>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type FindManyUserQueryResult = NonNullable<Awaited<ReturnType<typeof findManyUser>>>;
export type FindManyUserQueryError = AxiosError<_Error>;

export const useFindManyUser = <TData = Awaited<ReturnType<typeof findManyUser>>, TError = AxiosError<_Error>>(
  params: FindManyUserParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findManyUser>>, TError, TData>>; axios?: AxiosRequestConfig }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getFindManyUserQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update a User
 */
export const updateUser = (userUpdateArgs: UserUpdateArgs, options?: AxiosRequestConfig): Promise<AxiosResponse<UpdateUser200>> => {
  return axios.patch(`http://localhost:3000/api/model/user/update`, userUpdateArgs, options);
};

export const getUpdateUserMutationOptions = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError, { data: UserUpdateArgs }, TContext>;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError, { data: UserUpdateArgs }, TContext> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, { data: UserUpdateArgs }> = (props) => {
    const { data } = props ?? {};

    return updateUser(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>;
export type UpdateUserMutationBody = UserUpdateArgs;
export type UpdateUserMutationError = AxiosError<_Error>;

export const useUpdateUser = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError, { data: UserUpdateArgs }, TContext>;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getUpdateUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Update Users matching the given condition
 */
export const updateManyUser = (
  userUpdateManyArgs: UserUpdateManyArgs,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<UpdateManyUser200>> => {
  return axios.patch(`http://localhost:3000/api/model/user/updateMany`, userUpdateManyArgs, options);
};

export const getUpdateManyUserMutationOptions = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateManyUser>>, TError, { data: UserUpdateManyArgs }, TContext>;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<Awaited<ReturnType<typeof updateManyUser>>, TError, { data: UserUpdateManyArgs }, TContext> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateManyUser>>, { data: UserUpdateManyArgs }> = (props) => {
    const { data } = props ?? {};

    return updateManyUser(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateManyUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateManyUser>>>;
export type UpdateManyUserMutationBody = UserUpdateManyArgs;
export type UpdateManyUserMutationError = AxiosError<_Error>;

export const useUpdateManyUser = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateManyUser>>, TError, { data: UserUpdateManyArgs }, TContext>;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getUpdateManyUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Upsert a User
 */
export const upsertUser = (userUpsertArgs: UserUpsertArgs, options?: AxiosRequestConfig): Promise<AxiosResponse<UpsertUser200>> => {
  return axios.post(`http://localhost:3000/api/model/user/upsert`, userUpsertArgs, options);
};

export const getUpsertUserMutationOptions = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof upsertUser>>, TError, { data: UserUpsertArgs }, TContext>;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<Awaited<ReturnType<typeof upsertUser>>, TError, { data: UserUpsertArgs }, TContext> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof upsertUser>>, { data: UserUpsertArgs }> = (props) => {
    const { data } = props ?? {};

    return upsertUser(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpsertUserMutationResult = NonNullable<Awaited<ReturnType<typeof upsertUser>>>;
export type UpsertUserMutationBody = UserUpsertArgs;
export type UpsertUserMutationError = AxiosError<_Error>;

export const useUpsertUser = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof upsertUser>>, TError, { data: UserUpsertArgs }, TContext>;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getUpsertUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete one unique User
 */
export const deleteUser = (params: DeleteUserParams, options?: AxiosRequestConfig): Promise<AxiosResponse<DeleteUser200>> => {
  return axios.delete(`http://localhost:3000/api/model/user/delete`, {
    ...options,
    params: { ...params, ...options?.params }
  });
};

export const getDeleteUserMutationOptions = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError, { params: DeleteUserParams }, TContext>;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError, { params: DeleteUserParams }, TContext> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, { params: DeleteUserParams }> = (props) => {
    const { params } = props ?? {};

    return deleteUser(params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>;

export type DeleteUserMutationError = AxiosError<_Error>;

export const useDeleteUser = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError, { params: DeleteUserParams }, TContext>;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getDeleteUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete Users matching the given condition
 */
export const deleteManyUser = (params: DeleteManyUserParams, options?: AxiosRequestConfig): Promise<AxiosResponse<DeleteManyUser200>> => {
  return axios.delete(`http://localhost:3000/api/model/user/deleteMany`, {
    ...options,
    params: { ...params, ...options?.params }
  });
};

export const getDeleteManyUserMutationOptions = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteManyUser>>, TError, { params: DeleteManyUserParams }, TContext>;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteManyUser>>, TError, { params: DeleteManyUserParams }, TContext> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteManyUser>>, { params: DeleteManyUserParams }> = (props) => {
    const { params } = props ?? {};

    return deleteManyUser(params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteManyUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteManyUser>>>;

export type DeleteManyUserMutationError = AxiosError<_Error>;

export const useDeleteManyUser = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteManyUser>>, TError, { params: DeleteManyUserParams }, TContext>;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getDeleteManyUserMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Find a list of User
 */
export const countUser = (params: CountUserParams, options?: AxiosRequestConfig): Promise<AxiosResponse<CountUser200>> => {
  return axios.get(`http://localhost:3000/api/model/user/count`, {
    ...options,
    params: { ...params, ...options?.params }
  });
};

export const getCountUserQueryKey = (params: CountUserParams) => {
  return [`http://localhost:3000/api/model/user/count`, ...(params ? [params] : [])] as const;
};

export const getCountUserQueryOptions = <TData = Awaited<ReturnType<typeof countUser>>, TError = AxiosError<_Error>>(
  params: CountUserParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof countUser>>, TError, TData>>; axios?: AxiosRequestConfig }
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCountUserQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof countUser>>> = ({ signal }) => countUser(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof countUser>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type CountUserQueryResult = NonNullable<Awaited<ReturnType<typeof countUser>>>;
export type CountUserQueryError = AxiosError<_Error>;

export const useCountUser = <TData = Awaited<ReturnType<typeof countUser>>, TError = AxiosError<_Error>>(
  params: CountUserParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof countUser>>, TError, TData>>; axios?: AxiosRequestConfig }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getCountUserQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Aggregate Users
 */
export const aggregateUser = (params: AggregateUserParams, options?: AxiosRequestConfig): Promise<AxiosResponse<AggregateUser200>> => {
  return axios.get(`http://localhost:3000/api/model/user/aggregate`, {
    ...options,
    params: { ...params, ...options?.params }
  });
};

export const getAggregateUserQueryKey = (params: AggregateUserParams) => {
  return [`http://localhost:3000/api/model/user/aggregate`, ...(params ? [params] : [])] as const;
};

export const getAggregateUserQueryOptions = <TData = Awaited<ReturnType<typeof aggregateUser>>, TError = AxiosError<_Error>>(
  params: AggregateUserParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof aggregateUser>>, TError, TData>>; axios?: AxiosRequestConfig }
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAggregateUserQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof aggregateUser>>> = ({ signal }) =>
    aggregateUser(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof aggregateUser>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type AggregateUserQueryResult = NonNullable<Awaited<ReturnType<typeof aggregateUser>>>;
export type AggregateUserQueryError = AxiosError<_Error>;

export const useAggregateUser = <TData = Awaited<ReturnType<typeof aggregateUser>>, TError = AxiosError<_Error>>(
  params: AggregateUserParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof aggregateUser>>, TError, TData>>; axios?: AxiosRequestConfig }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getAggregateUserQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Group Users by fields
 */
export const groupByUser = (params: GroupByUserParams, options?: AxiosRequestConfig): Promise<AxiosResponse<GroupByUser200>> => {
  return axios.get(`http://localhost:3000/api/model/user/groupBy`, {
    ...options,
    params: { ...params, ...options?.params }
  });
};

export const getGroupByUserQueryKey = (params: GroupByUserParams) => {
  return [`http://localhost:3000/api/model/user/groupBy`, ...(params ? [params] : [])] as const;
};

export const getGroupByUserQueryOptions = <TData = Awaited<ReturnType<typeof groupByUser>>, TError = AxiosError<_Error>>(
  params: GroupByUserParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof groupByUser>>, TError, TData>>; axios?: AxiosRequestConfig }
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGroupByUserQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof groupByUser>>> = ({ signal }) => groupByUser(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof groupByUser>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GroupByUserQueryResult = NonNullable<Awaited<ReturnType<typeof groupByUser>>>;
export type GroupByUserQueryError = AxiosError<_Error>;

export const useGroupByUser = <TData = Awaited<ReturnType<typeof groupByUser>>, TError = AxiosError<_Error>>(
  params: GroupByUserParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof groupByUser>>, TError, TData>>; axios?: AxiosRequestConfig }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGroupByUserQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Create a new Post
 */
export const createPost = (postCreateArgs: PostCreateArgs, options?: AxiosRequestConfig): Promise<AxiosResponse<CreatePost201>> => {
  return axios.post(`http://localhost:3000/api/model/post/create`, postCreateArgs, options);
};

export const getCreatePostMutationOptions = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof createPost>>, TError, { data: PostCreateArgs }, TContext>;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<Awaited<ReturnType<typeof createPost>>, TError, { data: PostCreateArgs }, TContext> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPost>>, { data: PostCreateArgs }> = (props) => {
    const { data } = props ?? {};

    return createPost(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreatePostMutationResult = NonNullable<Awaited<ReturnType<typeof createPost>>>;
export type CreatePostMutationBody = PostCreateArgs;
export type CreatePostMutationError = AxiosError<_Error>;

export const useCreatePost = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof createPost>>, TError, { data: PostCreateArgs }, TContext>;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getCreatePostMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Find one unique Post
 */
export const findUniquePost = (params: FindUniquePostParams, options?: AxiosRequestConfig): Promise<AxiosResponse<FindUniquePost200>> => {
  return axios.get(`http://localhost:3000/api/model/post/findUnique`, {
    ...options,
    params: { ...params, ...options?.params }
  });
};

export const getFindUniquePostQueryKey = (params: FindUniquePostParams) => {
  return [`http://localhost:3000/api/model/post/findUnique`, ...(params ? [params] : [])] as const;
};

export const getFindUniquePostQueryOptions = <TData = Awaited<ReturnType<typeof findUniquePost>>, TError = AxiosError<_Error>>(
  params: FindUniquePostParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findUniquePost>>, TError, TData>>; axios?: AxiosRequestConfig }
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindUniquePostQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findUniquePost>>> = ({ signal }) =>
    findUniquePost(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof findUniquePost>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type FindUniquePostQueryResult = NonNullable<Awaited<ReturnType<typeof findUniquePost>>>;
export type FindUniquePostQueryError = AxiosError<_Error>;

export const useFindUniquePost = <TData = Awaited<ReturnType<typeof findUniquePost>>, TError = AxiosError<_Error>>(
  params: FindUniquePostParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findUniquePost>>, TError, TData>>; axios?: AxiosRequestConfig }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getFindUniquePostQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Find the first Post matching the given condition
 */
export const findFirstPost = (params: FindFirstPostParams, options?: AxiosRequestConfig): Promise<AxiosResponse<FindFirstPost200>> => {
  return axios.get(`http://localhost:3000/api/model/post/findFirst`, {
    ...options,
    params: { ...params, ...options?.params }
  });
};

export const getFindFirstPostQueryKey = (params: FindFirstPostParams) => {
  return [`http://localhost:3000/api/model/post/findFirst`, ...(params ? [params] : [])] as const;
};

export const getFindFirstPostQueryOptions = <TData = Awaited<ReturnType<typeof findFirstPost>>, TError = AxiosError<_Error>>(
  params: FindFirstPostParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findFirstPost>>, TError, TData>>; axios?: AxiosRequestConfig }
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindFirstPostQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findFirstPost>>> = ({ signal }) =>
    findFirstPost(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof findFirstPost>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type FindFirstPostQueryResult = NonNullable<Awaited<ReturnType<typeof findFirstPost>>>;
export type FindFirstPostQueryError = AxiosError<_Error>;

export const useFindFirstPost = <TData = Awaited<ReturnType<typeof findFirstPost>>, TError = AxiosError<_Error>>(
  params: FindFirstPostParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findFirstPost>>, TError, TData>>; axios?: AxiosRequestConfig }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getFindFirstPostQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Find a list of Post
 */
export const findManyPost = (params: FindManyPostParams, options?: AxiosRequestConfig): Promise<AxiosResponse<FindManyPost200>> => {
  return axios.get(`http://localhost:3000/api/model/post/findMany`, {
    ...options,
    params: { ...params, ...options?.params }
  });
};

export const getFindManyPostQueryKey = (params: FindManyPostParams) => {
  return [`http://localhost:3000/api/model/post/findMany`, ...(params ? [params] : [])] as const;
};

export const getFindManyPostQueryOptions = <TData = Awaited<ReturnType<typeof findManyPost>>, TError = AxiosError<_Error>>(
  params: FindManyPostParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findManyPost>>, TError, TData>>; axios?: AxiosRequestConfig }
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindManyPostQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findManyPost>>> = ({ signal }) =>
    findManyPost(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof findManyPost>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type FindManyPostQueryResult = NonNullable<Awaited<ReturnType<typeof findManyPost>>>;
export type FindManyPostQueryError = AxiosError<_Error>;

export const useFindManyPost = <TData = Awaited<ReturnType<typeof findManyPost>>, TError = AxiosError<_Error>>(
  params: FindManyPostParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findManyPost>>, TError, TData>>; axios?: AxiosRequestConfig }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getFindManyPostQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Update a Post
 */
export const updatePost = (postUpdateArgs: PostUpdateArgs, options?: AxiosRequestConfig): Promise<AxiosResponse<UpdatePost200>> => {
  return axios.patch(`http://localhost:3000/api/model/post/update`, postUpdateArgs, options);
};

export const getUpdatePostMutationOptions = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof updatePost>>, TError, { data: PostUpdateArgs }, TContext>;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<Awaited<ReturnType<typeof updatePost>>, TError, { data: PostUpdateArgs }, TContext> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePost>>, { data: PostUpdateArgs }> = (props) => {
    const { data } = props ?? {};

    return updatePost(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdatePostMutationResult = NonNullable<Awaited<ReturnType<typeof updatePost>>>;
export type UpdatePostMutationBody = PostUpdateArgs;
export type UpdatePostMutationError = AxiosError<_Error>;

export const useUpdatePost = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof updatePost>>, TError, { data: PostUpdateArgs }, TContext>;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getUpdatePostMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Update Posts matching the given condition
 */
export const updateManyPost = (
  postUpdateManyArgs: PostUpdateManyArgs,
  options?: AxiosRequestConfig
): Promise<AxiosResponse<UpdateManyPost200>> => {
  return axios.patch(`http://localhost:3000/api/model/post/updateMany`, postUpdateManyArgs, options);
};

export const getUpdateManyPostMutationOptions = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateManyPost>>, TError, { data: PostUpdateManyArgs }, TContext>;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<Awaited<ReturnType<typeof updateManyPost>>, TError, { data: PostUpdateManyArgs }, TContext> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateManyPost>>, { data: PostUpdateManyArgs }> = (props) => {
    const { data } = props ?? {};

    return updateManyPost(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateManyPostMutationResult = NonNullable<Awaited<ReturnType<typeof updateManyPost>>>;
export type UpdateManyPostMutationBody = PostUpdateManyArgs;
export type UpdateManyPostMutationError = AxiosError<_Error>;

export const useUpdateManyPost = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof updateManyPost>>, TError, { data: PostUpdateManyArgs }, TContext>;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getUpdateManyPostMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Upsert a Post
 */
export const upsertPost = (postUpsertArgs: PostUpsertArgs, options?: AxiosRequestConfig): Promise<AxiosResponse<UpsertPost200>> => {
  return axios.post(`http://localhost:3000/api/model/post/upsert`, postUpsertArgs, options);
};

export const getUpsertPostMutationOptions = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof upsertPost>>, TError, { data: PostUpsertArgs }, TContext>;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<Awaited<ReturnType<typeof upsertPost>>, TError, { data: PostUpsertArgs }, TContext> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof upsertPost>>, { data: PostUpsertArgs }> = (props) => {
    const { data } = props ?? {};

    return upsertPost(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpsertPostMutationResult = NonNullable<Awaited<ReturnType<typeof upsertPost>>>;
export type UpsertPostMutationBody = PostUpsertArgs;
export type UpsertPostMutationError = AxiosError<_Error>;

export const useUpsertPost = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof upsertPost>>, TError, { data: PostUpsertArgs }, TContext>;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getUpsertPostMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete one unique Post
 */
export const deletePost = (params: DeletePostParams, options?: AxiosRequestConfig): Promise<AxiosResponse<DeletePost200>> => {
  return axios.delete(`http://localhost:3000/api/model/post/delete`, {
    ...options,
    params: { ...params, ...options?.params }
  });
};

export const getDeletePostMutationOptions = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deletePost>>, TError, { params: DeletePostParams }, TContext>;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<Awaited<ReturnType<typeof deletePost>>, TError, { params: DeletePostParams }, TContext> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePost>>, { params: DeletePostParams }> = (props) => {
    const { params } = props ?? {};

    return deletePost(params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeletePostMutationResult = NonNullable<Awaited<ReturnType<typeof deletePost>>>;

export type DeletePostMutationError = AxiosError<_Error>;

export const useDeletePost = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deletePost>>, TError, { params: DeletePostParams }, TContext>;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getDeletePostMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Delete Posts matching the given condition
 */
export const deleteManyPost = (params: DeleteManyPostParams, options?: AxiosRequestConfig): Promise<AxiosResponse<DeleteManyPost200>> => {
  return axios.delete(`http://localhost:3000/api/model/post/deleteMany`, {
    ...options,
    params: { ...params, ...options?.params }
  });
};

export const getDeleteManyPostMutationOptions = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteManyPost>>, TError, { params: DeleteManyPostParams }, TContext>;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteManyPost>>, TError, { params: DeleteManyPostParams }, TContext> => {
  const { mutation: mutationOptions, axios: axiosOptions } = options ?? {};

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteManyPost>>, { params: DeleteManyPostParams }> = (props) => {
    const { params } = props ?? {};

    return deleteManyPost(params, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteManyPostMutationResult = NonNullable<Awaited<ReturnType<typeof deleteManyPost>>>;

export type DeleteManyPostMutationError = AxiosError<_Error>;

export const useDeleteManyPost = <TError = AxiosError<_Error>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteManyPost>>, TError, { params: DeleteManyPostParams }, TContext>;
  axios?: AxiosRequestConfig;
}) => {
  const mutationOptions = getDeleteManyPostMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Find a list of Post
 */
export const countPost = (params: CountPostParams, options?: AxiosRequestConfig): Promise<AxiosResponse<CountPost200>> => {
  return axios.get(`http://localhost:3000/api/model/post/count`, {
    ...options,
    params: { ...params, ...options?.params }
  });
};

export const getCountPostQueryKey = (params: CountPostParams) => {
  return [`http://localhost:3000/api/model/post/count`, ...(params ? [params] : [])] as const;
};

export const getCountPostQueryOptions = <TData = Awaited<ReturnType<typeof countPost>>, TError = AxiosError<_Error>>(
  params: CountPostParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof countPost>>, TError, TData>>; axios?: AxiosRequestConfig }
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCountPostQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof countPost>>> = ({ signal }) => countPost(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof countPost>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type CountPostQueryResult = NonNullable<Awaited<ReturnType<typeof countPost>>>;
export type CountPostQueryError = AxiosError<_Error>;

export const useCountPost = <TData = Awaited<ReturnType<typeof countPost>>, TError = AxiosError<_Error>>(
  params: CountPostParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof countPost>>, TError, TData>>; axios?: AxiosRequestConfig }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getCountPostQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Aggregate Posts
 */
export const aggregatePost = (params: AggregatePostParams, options?: AxiosRequestConfig): Promise<AxiosResponse<AggregatePost200>> => {
  return axios.get(`http://localhost:3000/api/model/post/aggregate`, {
    ...options,
    params: { ...params, ...options?.params }
  });
};

export const getAggregatePostQueryKey = (params: AggregatePostParams) => {
  return [`http://localhost:3000/api/model/post/aggregate`, ...(params ? [params] : [])] as const;
};

export const getAggregatePostQueryOptions = <TData = Awaited<ReturnType<typeof aggregatePost>>, TError = AxiosError<_Error>>(
  params: AggregatePostParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof aggregatePost>>, TError, TData>>; axios?: AxiosRequestConfig }
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAggregatePostQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof aggregatePost>>> = ({ signal }) =>
    aggregatePost(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof aggregatePost>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type AggregatePostQueryResult = NonNullable<Awaited<ReturnType<typeof aggregatePost>>>;
export type AggregatePostQueryError = AxiosError<_Error>;

export const useAggregatePost = <TData = Awaited<ReturnType<typeof aggregatePost>>, TError = AxiosError<_Error>>(
  params: AggregatePostParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof aggregatePost>>, TError, TData>>; axios?: AxiosRequestConfig }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getAggregatePostQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * Group Posts by fields
 */
export const groupByPost = (params: GroupByPostParams, options?: AxiosRequestConfig): Promise<AxiosResponse<GroupByPost200>> => {
  return axios.get(`http://localhost:3000/api/model/post/groupBy`, {
    ...options,
    params: { ...params, ...options?.params }
  });
};

export const getGroupByPostQueryKey = (params: GroupByPostParams) => {
  return [`http://localhost:3000/api/model/post/groupBy`, ...(params ? [params] : [])] as const;
};

export const getGroupByPostQueryOptions = <TData = Awaited<ReturnType<typeof groupByPost>>, TError = AxiosError<_Error>>(
  params: GroupByPostParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof groupByPost>>, TError, TData>>; axios?: AxiosRequestConfig }
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGroupByPostQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof groupByPost>>> = ({ signal }) => groupByPost(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof groupByPost>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GroupByPostQueryResult = NonNullable<Awaited<ReturnType<typeof groupByPost>>>;
export type GroupByPostQueryError = AxiosError<_Error>;

export const useGroupByPost = <TData = Awaited<ReturnType<typeof groupByPost>>, TError = AxiosError<_Error>>(
  params: GroupByPostParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof groupByPost>>, TError, TData>>; axios?: AxiosRequestConfig }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGroupByPostQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};
